import React, { useState, useCallback, useEffect, useRef } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { DATASOURCEMAP } from '@/config/dataSource';
import { setActiveConnectDataSource, setSocialSourcesAsync, setAttestLoading, setActiveAttestation, setThemeAction, initSetThemeAction } from '@/store/actions';
import CreateZkAttestation from '@/newComponents/ZkAttestation/CreateZkAttestation';
import useDataSource from '@/hooks/useDataSource';
import type { UserState } from '@/types/store';
import type { Dispatch } from 'react';
import { webDataSourceTemplate } from '@/config/webDataSourceTemplate';
import useMsgs from '@/hooks/useMsgs';
import { postMsg } from '@/utils/utils';
import { STARTOFFLINETIMEOUT } from '@/config/constants';
import { getZkPadoUrl, getProxyUrl } from '@/config/envConstants';
import { v4 as uuidv4 } from 'uuid';
import { eventReport } from '@/services/api/usertracker';
import WebTikTok from '@/services/webdata/websocial/webtiktok';
import empty from '@/assets/newImg/dataSource/empty.svg';
import PSwitch from '@/newComponents/PSwitch';
import WebXiaohongshu from '@/services/webdata/websocial/webxiaohongshu';
import iconDataSourceInstagram from '@/assets/img/iconDataSourceInstagram.svg';
import iconSettings from '@/assets/newImg/layout/iconMore.svg';

import './index.scss';
import { saveHandleMapping, doesMappingExist, findXiaohongshuByTiktok } from '@/services/firestore';
import HandleSearch from '@/newComponents/HandleSearch';

interface TikTokFollower {
  userId: string;
  uniqueId: string;
  nickname: string;
  avatar: string;
  followerCount: number;
  followingCount: number;
  signature: string;
  xiaohongshuHandle?: string;  // Optional field for associated Xiaohongshu handle
  isFollowingOnXiaohongshu?: boolean;  // Optional field for following status on Xiaohongshu
  isLoadingXiaohongshu?: boolean;  // To track loading state per follower
}

interface TikTokFollowersData {
  users: TikTokFollower[];
  hasMore: boolean;
  total: number;
  cursor: number;
  timestamp?: number;
}

function exportToCSV(data: TikTokFollower[], filename: string) {
  // Define CSV headers
  const headers = ['Username', 'Nickname', 'Followers', 'Following', 'Bio'];
  
  // Convert data to CSV format
  const csvContent = [
    headers.join(','),
    ...data.map(user => [
      `@${user.uniqueId}`,
      `"${user.nickname.replace(/"/g, '""')}"`, // Escape quotes in nicknames
      user.followerCount,
      user.followingCount,
      `"${user.signature.replace(/"/g, '""')}"` // Escape quotes in bios
    ].join(','))
  ].join('\n');

  // Create blob and download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `${filename}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// Function to follow a user on Xiaohongshu by their handle
const followOnXiaohongshu = async (handle: string, userId: string): Promise<{ success: boolean, userId: string }> => {
  return new Promise((resolve) => {
    // First, mark this user as "in progress" in localStorage to handle component remounts
    try {
      const followingInProgress = JSON.parse(localStorage.getItem('followingInProgress') || '{}');
      followingInProgress[userId] = { handle, timestamp: Date.now() };
      localStorage.setItem('followingInProgress', JSON.stringify(followingInProgress));
    } catch (e) {
      // Silent fail
    }
    
    let hasResolved = false;
    
    // Set a timeout in case we never get a response
    const timeoutId = setTimeout(() => {
      if (!hasResolved) {
        hasResolved = true;
        
        // Try to check chrome.storage as a last resort before failing
        chrome.storage.local.get(['successfulXiaohongshuFollows'], (result) => {
          const storedFollows = result.successfulXiaohongshuFollows || {};
          
          // If we already have a success stored despite the timeout, report success
          if (storedFollows[userId]?.success) {
            resolve({ success: true, userId });
            return;
          }
          
          resolve({ success: false, userId });
        });
      }
    }, 60000); // 60 second timeout
    
    // Send message to background script to handle the follow
    try {
      chrome.runtime.sendMessage({
        type: 'xiaohongshu_follow',
        data: {
          handle,
          userId
        }
      });
      
      // Listen for a direct response message
      const messageListener = (message: any) => {
        // Only process messages related to this follow request
        if (
          (message.type === 'xiaohongshu_follow_result' && message.data?.userId === userId) ||
          (message.type === 'xiaohongshu_direct_follow_result' && message.userId === userId)
        ) {
          // Clear the message listener
          chrome.runtime.onMessage.removeListener(messageListener);
          
          // Clear the timeout
          clearTimeout(timeoutId);
          
          // Determine success status
          const success = message.data?.success || message.success || false;
          
          // Prevent multiple resolves
          if (!hasResolved) {
            hasResolved = true;
            resolve({ success, userId });
          }
        }
      };
      
      // Add the listener
      chrome.runtime.onMessage.addListener(messageListener);
      
      // Clean up the listener if the component unmounts
      return () => {
        chrome.runtime.onMessage.removeListener(messageListener);
        clearTimeout(timeoutId);
      };
    } catch (e) {
      // Handle error silently
      if (!hasResolved) {
        hasResolved = true;
        resolve({ success: false, userId });
      }
    }
  });
};

const IdentityBridge = () => {
  const { addMsg, deleteMsg } = useMsgs();
  const [visibleAssetDialog, setVisibleAssetDialog] = useState<string>('');
  const [attestationPresets, setAttestationPresets] = useState<any>();
  const dispatch: Dispatch<any> = useDispatch();
  const webProofTypes = useSelector((state: UserState) => state.webProofTypes);
  const activeConnectDataSource = useSelector(
    (state: UserState) => state.activeConnectDataSource
  );
  const attestLoading = useSelector((state: UserState) => state.attestLoading);
  const padoServicePort = useSelector((state: UserState) => state.padoServicePort);
  const theme = useSelector((state: UserState) => state.theme);
  const [followers, setFollowers] = useState<TikTokFollower[]>([]);
  const [hasMoreFollowers, setHasMoreFollowers] = useState(false);
  const [followersCursor, setFollowersCursor] = useState(0);
  const [totalFollowers, setTotalFollowers] = useState(0);
  const [following, setFollowing] = useState<TikTokFollower[]>([]);
  const [hasMoreFollowing, setHasMoreFollowing] = useState(false);
  const [followingCursor, setFollowingCursor] = useState(0);
  const [totalFollowing, setTotalFollowing] = useState(0);
  const [isHandleMappingSaved, setIsHandleMappingSaved] = useState<boolean>(false);
  const [saveMappingError, setSaveMappingError] = useState<string | null>(null);
  const [hasAutoSaved, setHasAutoSaved] = useState<boolean>(false);
  const [autoSaveError, setAutoSaveError] = useState<string | null>(null);
  const [mappingWasFound, setMappingWasFound] = useState<boolean>(false);
  const [showDebugging, setShowDebugging] = useState<boolean>(false);
  const [expandedUser, setExpandedUser] = useState<string | null>(null);

  // Add state variables for debugging
  const [lastFollowResult, setLastFollowResult] = useState<any>(null);
  const followersRef = useRef<any[]>([]);
  const followingRef = useRef<any[]>([]);
  
  // Add state variables for connection status
  const [connectionStatus, setConnectionStatus] = useState<'idle' | 'connecting' | 'connected' | 'error'>('idle');
  
  // Update refs when state changes - minimal logging
  useEffect(() => {
    // Only update ref, no logging needed
    followersRef.current = followers;
  }, [followers]);
  
  useEffect(() => {
    // Only update ref, no logging needed
    followingRef.current = following;
  }, [following]);

  const {
    metaInfo: activeDataSouceMetaInfo,
    userInfo: activeDataSouceUserInfo,
    deleteFn: deleteDataSourceFn,
  } = useDataSource('tiktok');

  const {
    metaInfo: xiaohongshuMetaInfo,
    userInfo: xiaohongshuUserInfo,
    deleteFn: deleteXiaohongshuFn,
  } = useDataSource('xiaohongshu');

  const hasConnected = activeDataSouceUserInfo?.userName;
  const hasXiaohongshuConnected = xiaohongshuUserInfo?.userName;

  // Create a ref to store the port and track active state
  const portRef = useRef<any>(null);
  const isActiveRef = useRef<boolean>(true);

  useEffect(() => {
    dispatch(setSocialSourcesAsync());
  }, [dispatch]);

  // Setup port connection for TikTok data
  useEffect(() => {
    const isActive = isActiveRef.current;
    if (isActive) {
      console.log('Creating new port connection');
      const port = chrome.runtime.connect({ name: `identityBridge-${Date.now()}` });
      portRef.current = port;
      isActiveRef.current = true;
      
      // Initial ping to establish connection
      port.postMessage({ type: 'ping' });
      
      // Set up message listener
      const messageListener = (message) => {
        // Process messages here, silently
        if (message.type === 'pong') {
          // Connection is alive
          return;
        }
        
        if (message.type === 'tiktok_followers_data') {
          const data = message.data;
          
          // Update followers with deduplication
          setFollowers(prevFollowers => {
            const existingIds = new Set(prevFollowers.map(f => f.userId));
            const newFollowers = data.users.filter(f => !existingIds.has(f.userId));
            return [...prevFollowers, ...newFollowers];
          });
          
          setHasMoreFollowers(data.hasMore);
          setFollowersCursor(data.cursor);
          setTotalFollowers(data.total);
          
          // Save to storage
          chrome.storage.local.set({
            'tiktok-followers-data': JSON.stringify({
              ...data,
              timestamp: Date.now()
            })
          });
        }
        
        if (message.type === 'tiktok_following_data') {
          const data = message.data;
          
          // Update following with deduplication
          setFollowing(prevFollowing => {
            const existingIds = new Set(prevFollowing.map(f => f.userId));
            const newFollowing = data.users.filter(f => !existingIds.has(f.userId));
            return [...prevFollowing, ...newFollowing];
          });
          
          setHasMoreFollowing(data.hasMore);
          setFollowingCursor(data.cursor);
          setTotalFollowing(data.total);
          
          // Save to storage
          chrome.storage.local.set({
            'tiktok-following-data': JSON.stringify({
              ...data,
              timestamp: Date.now()
            })
          });
        }
        
        if (message.type === 'connection_success') {
          setConnectionStatus('connected');
          dispatch(setActiveConnectDataSource({ 
            loading: 0,
            dataSourceId: 'tiktok'
          }));
        }
        
        if (message.type === 'connection_error') {
          setConnectionStatus('error');
          const msgId = addMsg({
            type: 'error',
            title: 'Connection Failed',
            desc: 'Failed to connect TikTok account. Please try again.',
            showTime: 5000,
          });
          setTimeout(() => deleteMsg(msgId), 5000);
        }
      };
      
      port.onMessage.addListener(messageListener);
      
      // Set up disconnect listener
      port.onDisconnect.addListener(() => {
        console.log('Port disconnected in IdentityBridge');
        portRef.current = null;
        
        // Only attempt to reconnect if still active
        if (isActiveRef.current) {
          setTimeout(() => {
            if (isActiveRef.current && !portRef.current) {
              console.log('Attempting to reconnect port');
              const newPort = chrome.runtime.connect({ name: `identityBridge-${Date.now()}` });
              portRef.current = newPort;
              
              // Setup listeners on new port
              newPort.onMessage.addListener(messageListener);
              newPort.onDisconnect.addListener(() => {
                console.log('Port disconnected in IdentityBridge');
                portRef.current = null;
              });
              
              // Initial ping to establish connection
              newPort.postMessage({ type: 'ping' });
            }
          }, 1000);
        }
      });
      
      // Cleanup function
      return () => {
        console.log('Cleaning up port connection in IdentityBridge');
        isActiveRef.current = false;
        
        if (portRef.current) {
          try {
            portRef.current.disconnect();
          } catch (e) {
            console.log('Error disconnecting port:', e);
          }
          portRef.current = null;
        }
      };
    }
  }, [dispatch, addMsg, deleteMsg]);

  // Update theme initialization
  useEffect(() => {
    if (!localStorage.getItem('colorTheme')) {
      localStorage.setItem('colorTheme', 'dark');
    }
    dispatch(initSetThemeAction());
  }, [dispatch]);

  const handleDelete = useCallback(async () => {
    await deleteDataSourceFn('tiktok');
    
    // Clear follower and following data from storage
    await chrome.storage.local.remove(['tiktok-followers-data', 'tiktok-following-data']);
    
    // Clear state
    setFollowers([]);
    setFollowing([]);
    setHasMoreFollowers(false);
    setHasMoreFollowing(false);
    setFollowersCursor(0);
    setFollowingCursor(0);
    setTotalFollowers(0);
    setTotalFollowing(0);
    
    const msgId = addMsg({
      type: 'info',
      title: 'TikTok data deleted',
      showTime: 5000,
    });
    setTimeout(() => {
      deleteMsg(msgId);
    }, 5000);
    dispatch(setSocialSourcesAsync());
  }, [deleteDataSourceFn, addMsg, deleteMsg, dispatch]);

  const handleConnect = useCallback(async () => {
    console.log('Connect button clicked');
    if (activeConnectDataSource.loading === 1) {
      console.log('Already loading, returning');
      return;
    }

    console.log('Setting loading state');
    await dispatch(
      setActiveConnectDataSource({
        loading: 1,
        dataSourceId: 'tiktok'
      })
    );
    
    // Ensure port is connected
    isActiveRef.current = true;
    if (!portRef.current) {
      const port = chrome.runtime.connect({ name: `identityBridge-${Date.now()}` });
      portRef.current = port;
      port.postMessage({ type: 'ping' });
    }

    let currRequestObj = webProofTypes.find(
      (r: any) => r.dataSource === 'tiktok' && r.name === 'Account Ownership'
    );

    if (!currRequestObj) {
      currRequestObj = {
        dataSource: 'tiktok',
        jumpTo: 'https://www.tiktok.com',
        datasourceTemplate: {
          requests: [
            {
              name: 'first',
              url: 'https://www.tiktok.com/passport/web/account/info/',
              method: 'GET',
              headers: ['cookie'],
              cookies: ['sessionid']
            }
          ],
          responses: [
            {
              conditions: {
                status: 200
              }
            }
          ]
        }
      };
    }

    const msgId = addMsg({
      type: 'info',
      title: 'Connecting to TikTok',
      desc: 'Please log in to your TikTok account when prompted.',
      showTime: 10000,
    });
    setTimeout(() => deleteMsg(msgId), 10000);

    console.log('Sending init message');
    chrome.runtime.sendMessage({
      type: 'dataSourceWeb',
      name: 'init',
      operation: 'connect',
      params: {
        ...currRequestObj,
      },
    });
  }, [dispatch, activeConnectDataSource, webProofTypes, addMsg, deleteMsg]);

  const handleAttest = useCallback(async () => {
    if (attestLoading === 1) {
      addMsg({
        type: 'info',
        title: 'Cannot process now',
        desc: 'Another attestation task is running. Please try again later.',
      });
      return;
    }

    await chrome.storage.local.remove([
      'activeRequestAttestation',
      'padoZKAttestationJSSDKBeginAttest',
      'beginAttest',
      'getAttestationResultRes'
    ]);

    const requestid = uuidv4();
    let currRequestObj = webProofTypes.find(
      (r: any) => r.dataSource === 'tiktok' && r.name === 'Account Ownership'
    );

    if (!currRequestObj) {
      currRequestObj = {
        dataSource: 'tiktok',
        jumpTo: 'https://www.tiktok.com',
        datasourceTemplate: {
          requests: [
            {
              name: 'first',
              url: 'https://www.tiktok.com/passport/web/account/info/',
              method: 'GET',
              headers: ['cookie'],
              cookies: ['sessionid']
            }
          ]
        }
      };
    }

    dispatch(setAttestLoading(1));
    dispatch(setActiveAttestation({ 
      attestationType: 'Humanity Verification',
      dataSourceId: 'tiktok',
      verificationContent: 'Account ownership',
      verificationValue: 'Account owner',
      fetchType: 'Web',
      loading: 1 
    }));

    const eventInfo = {
      eventType: 'ATTESTATION_NEXT',
      rawData: {
        source: 'tiktok',
        order: '1',
        requestid
      }
    };
    eventReport(eventInfo);

    chrome.runtime.sendMessage({
      type: 'dataSourceWeb',
      name: 'init',
      operation: 'attest',
      params: {
        ...currRequestObj,
        requestid,
        attestationType: 'Humanity Verification',
        fetchType: 'Web',
        uiTemplate: {
          condition: 'Account owner',
          proofContent: 'Account ownership',
          successMsg: 'Account ownership verified',
          failedMsg: 'Account ownership verification failed'
        }
      }
    });

  }, [attestLoading, addMsg, webProofTypes, activeDataSouceUserInfo, dispatch]);

  const handleCloseAssetDialog = useCallback(() => {
    setVisibleAssetDialog('');
  }, []);

  const handleSubmitAssetDialog = useCallback(() => {
    setVisibleAssetDialog('');
  }, []);

  const isLoading = activeConnectDataSource.loading === 1 && activeConnectDataSource.dataSourceId === 'tiktok';

  const handleXiaohongshuConnect = useCallback(async () => {
    if (activeConnectDataSource.loading === 1) {
      return;
    }

    await dispatch(
      setActiveConnectDataSource({
        loading: 1,
        dataSourceId: 'xiaohongshu'
      })
    );

    let currRequestObj = webProofTypes.find(
      (r: any) => r.dataSource === 'xiaohongshu' && r.name === 'Account Ownership'
    );

    if (!currRequestObj) {
      currRequestObj = {
        dataSource: 'xiaohongshu',
        jumpTo: 'https://www.xiaohongshu.com',
        datasourceTemplate: {
          requests: [
            {
              name: 'first',
              url: 'https://edith.xiaohongshu.com/api/sns/web/v2/user/me',
              method: 'GET',
              headers: ['cookie'],
              cookies: ['web_session']
            }
          ],
          responses: [
            {
              conditions: {
                status: 200
              }
            }
          ]
        }
      };
    }

    const msgId = addMsg({
      type: 'info',
      title: 'Connecting to Xiaohongshu',
      desc: 'Please log in to your Xiaohongshu account when prompted.',
      showTime: 10000,
    });
    setTimeout(() => deleteMsg(msgId), 10000);

    chrome.runtime.sendMessage({
      type: 'dataSourceWeb',
      name: 'init',
      operation: 'connect',
      params: {
        ...currRequestObj,
        uiTemplate: {
          condition: 'Account owner',
          proofContent: 'Account ownership',
          successMsg: 'Account ownership verified',
          failedMsg: 'Account ownership verification failed'
        }
      },
    });
  }, [dispatch, activeConnectDataSource, webProofTypes, addMsg, deleteMsg]);

  const handleXiaohongshuDelete = useCallback(async () => {
    await deleteXiaohongshuFn('xiaohongshu');
    const msgId = addMsg({
      type: 'info',
      title: 'Xiaohongshu data deleted',
      showTime: 5000,
    });
    setTimeout(() => {
      deleteMsg(msgId);
    }, 5000);
    dispatch(setSocialSourcesAsync());
  }, [deleteXiaohongshuFn, addMsg, deleteMsg, dispatch]);

  // Function to load more followers
  const loadMoreFollowers = useCallback(() => {
    if (hasMoreFollowers) {
      console.log('Loading more followers with cursor:', followersCursor);
      chrome.runtime.sendMessage({
        type: 'fetch_more_followers',
        data: { cursor: followersCursor }
      });
    }
  }, [hasMoreFollowers, followersCursor]);

  // Add function to load more following
  const loadMoreFollowing = useCallback(() => {
    if (hasMoreFollowing) {
      console.log('Loading more following with cursor:', followingCursor);
      chrome.runtime.sendMessage({
        type: 'fetch_more_following',
        data: { cursor: followingCursor }
      });
    }
  }, [hasMoreFollowing, followingCursor]);

  const handleExportFollowers = useCallback(() => {
    if (followers.length > 0) {
      exportToCSV(followers, `tiktok_followers_${activeDataSouceUserInfo?.userName}_${new Date().toISOString().split('T')[0]}`);
    }
  }, [followers, activeDataSouceUserInfo?.userName]);

  const handleExportFollowing = useCallback(() => {
    if (following.length > 0) {
      exportToCSV(following, `tiktok_following_${activeDataSouceUserInfo?.userName}_${new Date().toISOString().split('T')[0]}`);
    }
  }, [following, activeDataSouceUserInfo?.userName]);

  // Add listener for follower data via runtime messages
  useEffect(() => {
    const handleMessage = (message: any) => {
      console.log('Runtime message received in IdentityBridge:', message);
      if (message.type === 'tiktok_followers_data') {
        console.log('Processing followers data from runtime message:', message.data);
        const data: TikTokFollowersData = message.data;
        
        // Store followers data in chrome.storage.local
        chrome.storage.local.set({
          'tiktok-followers-data': JSON.stringify({
            ...data,
            timestamp: Date.now() // Add current timestamp
          })
        }, () => {
          console.log('Follower data saved to storage:', data);
        });
        
        setFollowers(prevFollowers => {
          const existingIds = new Set(prevFollowers.map(f => f.userId));
          const newFollowers = data.users.filter(f => !existingIds.has(f.userId));
          const updatedFollowers = [...prevFollowers, ...newFollowers];
          console.log('Updated followers list from runtime message:', updatedFollowers);
          return updatedFollowers;
        });
        setHasMoreFollowers(data.hasMore);
        setFollowersCursor(data.cursor);
        setTotalFollowers(data.total);
      }
      
      if (message.type === 'tiktok_following_data') {
        console.log('Processing following data from runtime message:', message.data);
        const data: TikTokFollowersData = message.data;
        
        // Store following data in chrome.storage.local
        chrome.storage.local.set({
          'tiktok-following-data': JSON.stringify({
            ...data,
            timestamp: Date.now() // Add current timestamp
          })
        }, () => {
          console.log('Following data saved to storage:', data);
        });
        
        setFollowing(prevFollowing => {
          const existingIds = new Set(prevFollowing.map(f => f.userId));
          const newFollowing = data.users.filter(f => !existingIds.has(f.userId));
          const updatedFollowing = [...prevFollowing, ...newFollowing];
          console.log('Updated following list from runtime message:', updatedFollowing);
          return updatedFollowing;
        });
        setHasMoreFollowing(data.hasMore);
        setFollowingCursor(data.cursor);
        setTotalFollowing(data.total);
      }
    };

    console.log('Setting up runtime message listener in IdentityBridge');
    chrome.runtime.onMessage.addListener(handleMessage);
    
    // Try to get any stored data on mount
    chrome.storage.local.get(['tiktok-followers-data', 'tiktok-following-data'], (result) => {
      if (result['tiktok-followers-data']) {
        try {
          const data = JSON.parse(result['tiktok-followers-data']);
          console.log('Found stored followers data:', data);
          if (data.users && Array.isArray(data.users)) {
            setFollowers(data.users);
            setHasMoreFollowers(data.hasMore);
            setFollowersCursor(data.cursor);
            setTotalFollowers(data.total);
          }
        } catch (error) {
          console.error('Error parsing stored followers data:', error);
        }
      }
      
      if (result['tiktok-following-data']) {
        try {
          const data = JSON.parse(result['tiktok-following-data']);
          console.log('Found stored following data:', data);
          if (data.users && Array.isArray(data.users)) {
            setFollowing(data.users);
            setHasMoreFollowing(data.hasMore);
            setFollowingCursor(data.cursor);
            setTotalFollowing(data.total);
          }
        } catch (error) {
          console.error('Error parsing stored following data:', error);
        }
      }
    });

    return () => {
      console.log('Removing runtime message listener in IdentityBridge');
      chrome.runtime.onMessage.removeListener(handleMessage);
    };
  }, []);

  // Auto-save mapping when both handles are available
  useEffect(() => {
    const autoSaveHandleMapping = async () => {
      // Only proceed if both handles are connected and we haven't auto-saved yet
      if (hasConnected && hasXiaohongshuConnected && !hasAutoSaved) {
        try {
          // Get handles from state
          const tiktokHandle = activeDataSouceUserInfo?.userName;
          const xiaohongshuHandle = xiaohongshuUserInfo?.userName;
          const xiaohongshuUserId = xiaohongshuUserInfo?.userId; // Get the userId
          
          console.log('Xiaohongshu user info:', { 
            handle: xiaohongshuHandle, 
            userId: xiaohongshuUserId,
            fullInfo: xiaohongshuUserInfo
          });
          
          if (!tiktokHandle || !xiaohongshuHandle) {
            setAutoSaveError('Unable to retrieve handle information. Please reconnect your accounts.');
            return;
          }

          // Check if this exact mapping already exists
          const alreadyExists = await doesMappingExist(tiktokHandle, xiaohongshuHandle);
          
          if (alreadyExists) {
            // Mapping already exists, so just update the UI state without saving again
            console.log('Mapping already exists, not saving duplicate');
            setHasAutoSaved(true);
            setMappingWasFound(true);
            setAutoSaveError(null);
            
            // Show an info message
            const msgId = addMsg({
              type: 'info',
              title: 'Handle Mapping Found',
              desc: `Mapping between TikTok @${tiktokHandle} and Xiaohongshu @${xiaohongshuHandle} already exists`,
              showTime: 5000,
            });
            setTimeout(() => deleteMsg(msgId), 5000);
            return;
          }

          // If not already exists, save mapping to Firestore (now with userId)
          await saveHandleMapping(tiktokHandle, xiaohongshuHandle, xiaohongshuUserId);
          
          // Also save to chrome.storage for access in background script
          if (xiaohongshuUserId) {
            try {
              console.log(`Saving userId mapping to chrome.storage: ${xiaohongshuHandle} -> ${xiaohongshuUserId}`);
              
              // Get existing mappings first
              chrome.storage.local.get(['xiaohongshuUserIdMappings'], (result) => {
                const existingMappings = result.xiaohongshuUserIdMappings || {};
                
                // Add this mapping
                const updatedMappings = {
                  ...existingMappings,
                  [xiaohongshuHandle]: xiaohongshuUserId
                };
                
                // Save back to storage
                chrome.storage.local.set({ 
                  xiaohongshuUserIdMappings: updatedMappings 
                }, () => {
                  console.log('Saved userId mapping to chrome.storage successfully');
                });
              });
            } catch (error) {
              console.error('Error saving to chrome.storage:', error);
              // Continue anyway since we have Firestore as backup
            }
          }
          
          // Update UI state
          setHasAutoSaved(true);
          setMappingWasFound(false);
          setAutoSaveError(null);
          
          // Show success message
          const msgId = addMsg({
            type: 'success',
            title: 'Handle Mapping Saved',
            desc: `Successfully saved mapping from TikTok @${tiktokHandle} to Xiaohongshu @${xiaohongshuHandle}`,
            showTime: 5000,
          });
          setTimeout(() => deleteMsg(msgId), 5000);
        } catch (error) {
          console.error('Error auto-saving handle mapping:', error);
          setAutoSaveError('Failed to auto-save handle mapping. You can try again later.');
          
          // Show error message
          const msgId = addMsg({
            type: 'error',
            title: 'Error Saving Mapping',
            desc: 'There was a problem automatically saving your handle mapping.',
            showTime: 5000,
          });
          setTimeout(() => deleteMsg(msgId), 5000);
        }
      }
    };

    autoSaveHandleMapping();
  }, [hasConnected, hasXiaohongshuConnected, activeDataSouceUserInfo, xiaohongshuUserInfo, addMsg, deleteMsg, hasAutoSaved]);

  // Reset auto-save state when connections change
  useEffect(() => {
    if (!hasConnected || !hasXiaohongshuConnected) {
      setHasAutoSaved(false);
      setMappingWasFound(false);
    }
  }, [hasConnected, hasXiaohongshuConnected]);

  // Add a toggle handler function
  const toggleDebugging = useCallback(() => {
    setShowDebugging(prev => !prev);
  }, []);

  // Replace the lookupXiaohongshuHandles function with this improved version
  const lookupXiaohongshuHandles = useCallback(async (users: TikTokFollower[], setUsers: (users: TikTokFollower[]) => void) => {
    if (!users || users.length === 0) return;

    // Create a copy of the users array
    const updatedUsers = [...users];
    let hasChanges = false;

    // Find users that need to be processed (haven't been processed yet)
    const usersToProcess = updatedUsers
      .map((user, index) => ({ user, index }))
      .filter(({ user }) => user.xiaohongshuHandle === undefined && !user.isLoadingXiaohongshu);
    
    // If all users are already processed or being processed, exit early
    if (usersToProcess.length === 0) return;
    
    // Mark all users in the batch as loading first
    for (const { user, index } of usersToProcess) {
      updatedUsers[index] = { ...user, isLoadingXiaohongshu: true };
      hasChanges = true;
    }
    
    // Update the UI to show loading state
    if (hasChanges) {
      setUsers([...updatedUsers]);
    }
    
    // Process users in batches to avoid overwhelming Firestore
    const batchSize = 5;
    for (let i = 0; i < usersToProcess.length; i += batchSize) {
      const batch = usersToProcess.slice(i, i + batchSize);
      hasChanges = false;
      
      // Process each user in the batch concurrently
      await Promise.all(batch.map(async ({ user, index }) => {
        try {
          // Look up the Xiaohongshu handle for this TikTok handle
          const result = await findXiaohongshuByTiktok(user.uniqueId);
          
          // Update the user with the result
          updatedUsers[index] = { 
            ...updatedUsers[index], 
            xiaohongshuHandle: result?.xiaohongshuHandle || '', // Empty string for not found
            isLoadingXiaohongshu: false
          };
          
          hasChanges = true;
        } catch (error) {
          console.error(`Error looking up Xiaohongshu handle for @${user.uniqueId}:`, error);
          // Mark as failed but not loading
          updatedUsers[index] = { 
            ...updatedUsers[index], 
            xiaohongshuHandle: '', // Empty string for errors too
            isLoadingXiaohongshu: false
          };
          hasChanges = true;
        }
      }));
      
      // Update the state after each batch if needed
      if (hasChanges) {
        setUsers([...updatedUsers]);
      }
      
      // Small delay to avoid overloading Firestore
      await new Promise(resolve => setTimeout(resolve, 300));
    }
  }, []);

  // Fix the useEffect dependencies to avoid the infinite update loop
  useEffect(() => {
    const needsLookup = followers?.some(f => f.xiaohongshuHandle === undefined && !f.isLoadingXiaohongshu);
    
    if (followers && followers.length > 0 && needsLookup) {
      lookupXiaohongshuHandles(followers, setFollowers);
    }
  }, [followers?.length, lookupXiaohongshuHandles]); // Only re-run when length changes, not the array contents

  useEffect(() => {
    const needsLookup = following?.some(f => f.xiaohongshuHandle === undefined && !f.isLoadingXiaohongshu);
    
    if (following && following.length > 0 && needsLookup) {
      lookupXiaohongshuHandles(following, setFollowing);
    }
  }, [following?.length, lookupXiaohongshuHandles]); // Only re-run when length changes, not the array contents

  // Add a function to toggle expanded user details
  const toggleUserDetails = useCallback((userId: string) => {
    setExpandedUser(prevId => prevId === userId ? null : userId);
  }, []);

  // Add a listener for xiaohongshu follow results
  useEffect(() => {
    // Keep track of which userIds have been processed to prevent duplicate updates
    const processedUserIds = new Set<string>();
    
    const handleFollowResult = (message: any) => {
      // Extract data from different possible message formats - no logging
      let success = false;
      let userId = '';
      let handle = '';
      
      try {
        // Handle xiaohongshu_follow_result format
        if (message.type === 'xiaohongshu_follow_result' && message.data) {
          success = !!message.data.success;
          userId = message.data.userId;
          handle = message.data.handle;
        }
        // Handle xiaohongshu_direct_follow_result format
        else if (message.type === 'xiaohongshu_direct_follow_result') {
          success = !!message.success;
          userId = message.userId;
          handle = message.handle;
        }
        // Handle xiaohongshu_follow_success_local format
        else if (message.type === 'xiaohongshu_follow_success_local' && message.data) {
          success = !!message.data.success;
          userId = message.data.userId;
          handle = message.data.handle;
        }
        // Handle raw response format
        else if (message.success !== undefined || message.followSuccess !== undefined) {
          success = !!message.success || !!message.followSuccess;
          userId = message.userId;
          handle = message.handle;
        }
        else {
          // Not a follow result message we can handle
          return;
        }
        
        // Skip if we've already processed this userId in this session
        if (processedUserIds.has(userId)) {
          return;
        }
        
        // Only proceed with a valid userId
        if (!userId) return;
        
        if (success) {
          // Mark this userId as processed
          processedUserIds.add(userId);
          
          // First check if this user is already marked as following in state
          const followerIndex = followersRef.current.findIndex(f => f.userId === userId);
          const followingIndex = followingRef.current.findIndex(f => f.userId === userId);
          
          const alreadyFollowingInFollowers = followerIndex !== -1 && followersRef.current[followerIndex].isFollowingOnXiaohongshu;
          const alreadyFollowingInFollowing = followingIndex !== -1 && followingRef.current[followingIndex].isFollowingOnXiaohongshu;
          
          // If already marked as following in both arrays, just update UI without state changes
          if (alreadyFollowingInFollowers && alreadyFollowingInFollowing) {
            // Just update DOM directly, silently
            setTimeout(() => {
              document.querySelectorAll(`[data-userid="${userId}"] ~ td .following-status.no`).forEach(el => {
                el.className = 'following-status yes';
                el.textContent = 'Yes';
              });
              
              // Reset any loading buttons
              document.querySelectorAll('.follow-button.loading').forEach(btn => {
                const parentSpan = btn.closest('.following-status');
                if (parentSpan) {
                  parentSpan.className = 'following-status yes';
                  parentSpan.textContent = 'Yes';
                }
              });
            }, 100);
            
            return;
          }
          
          // Update the followers array only if needed
          if (followerIndex !== -1 && !alreadyFollowingInFollowers) {
            setFollowers(prev => {
              const updated = [...prev];
              updated[followerIndex] = {
                ...updated[followerIndex],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
              return updated;
            });
          }
          
          // Update the following array only if needed
          if (followingIndex !== -1 && !alreadyFollowingInFollowing) {
            setFollowing(prev => {
              const updated = [...prev];
              updated[followingIndex] = {
                ...updated[followingIndex],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
              return updated;
            });
          }
          
          // Add to localStorage for persistence, silently
          try {
            const successfulFollows = JSON.parse(localStorage.getItem('successfulFollows') || '{}');
            successfulFollows[userId] = { 
              handle,
              timestamp: Date.now(),
              success: true
            };
            localStorage.setItem('successfulFollows', JSON.stringify(successfulFollows));
            
            // Also store in chrome.storage
            chrome.storage.local.get(['successfulXiaohongshuFollows'], (result) => {
              const existingFollows = result.successfulXiaohongshuFollows || {};
              const updatedFollows = {
                ...existingFollows,
                [userId]: {
                  handle,
                  timestamp: Date.now(),
                  success: true
                }
              };
              chrome.storage.local.set({ successfulXiaohongshuFollows: updatedFollows });
            });
          } catch (e) {
            // Silent error, no logging
          }
          
          // Update the UI directly
          setTimeout(() => {
            document.querySelectorAll(`[data-userid="${userId}"] ~ td .following-status.no`).forEach(el => {
              el.className = 'following-status yes';
              el.textContent = 'Yes';
            });
            
            // Reset loading buttons
            document.querySelectorAll('.follow-button.loading').forEach(btn => {
              const parentSpan = btn.closest('.following-status');
              if (parentSpan) {
                parentSpan.className = 'following-status yes';
                parentSpan.textContent = 'Yes';
              }
            });
          }, 100);
        } else {
          // Process failed follows
          processedUserIds.add(userId);
          
          // Update loading state in case of failure
          const updateLoadingState = (userId: string, array: TikTokFollower[]) => {
            const index = array.findIndex(item => item.userId === userId);
            if (index !== -1 && array[index].isLoadingXiaohongshu) {
              const updated = [...array];
              updated[index] = {
                ...updated[index],
                isLoadingXiaohongshu: false
              };
              return updated;
            }
            return array;
          };
          
          // Only update if the user is in the loading state
          const updatedFollowers = updateLoadingState(userId, followersRef.current);
          if (updatedFollowers !== followersRef.current) {
            setFollowers(updatedFollowers);
          }
          
          const updatedFollowing = updateLoadingState(userId, followingRef.current);
          if (updatedFollowing !== followingRef.current) {
            setFollowing(updatedFollowing);
          }
          
          // Reset loading buttons
          document.querySelectorAll('.follow-button.loading').forEach(btn => {
            btn.classList.remove('loading');
            if (btn instanceof HTMLButtonElement) {
              btn.textContent = 'Follow';
              btn.disabled = false;
            }
          });
        }
      } catch (e) {
        // Silent error, no logging
      }
    };
    
    // Add global message listener
    chrome.runtime.onMessage.addListener(handleFollowResult);
    
    return () => {
      chrome.runtime.onMessage.removeListener(handleFollowResult);
    };
  }, []);

  // Updated follow function with more debugging
  const handleFollowUser = async (handle: string, userId: string, isFollower: boolean) => {
    // Set loading state
    const targetArray = isFollower ? followers : following;
    const userIndex = targetArray.findIndex(user => user.userId === userId);
    
    if (userIndex >= 0) {
      // Update loading state in the appropriate array
      if (isFollower) {
        setFollowers(prev => {
          const updated = [...prev];
          updated[userIndex] = {
            ...updated[userIndex],
            isLoadingXiaohongshu: true
          };
          return updated;
        });
      } else {
        setFollowing(prev => {
          const updated = [...prev];
          updated[userIndex] = {
            ...updated[userIndex],
            isLoadingXiaohongshu: true
          };
          return updated;
        });
      }
    }
    
    try {
      // Find the button that was clicked and mark it as loading
      const button = document.querySelector(`[data-userid="${userId}"] ~ td .follow-button`);
      if (button) {
        button.classList.add('loading');
        if (button instanceof HTMLButtonElement) {
          button.textContent = 'Loading...';
          button.disabled = true;
        }
      }
      
      // Attempt to follow the user
      const result = await followOnXiaohongshu(handle, userId);
      
      if (result.success) {
        // Directly update the button/cell UI
        setTimeout(() => {
          const statusElement = button?.closest('.following-status');
          if (statusElement) {
            statusElement.className = 'following-status yes';
            statusElement.textContent = 'Yes';
          } else {
            // If we couldn't find the button's parent, try to find the status cell by userId
            document.querySelectorAll(`[data-userid="${userId}"] ~ td .following-status.no`).forEach(el => {
              el.className = 'following-status yes';
              el.textContent = 'Yes';
            });
          }
        }, 100);
        
        // Update followers array if needed
        if (isFollower) {
          setFollowers(prev => {
            const updatedFollowers = [...prev];
            const index = updatedFollowers.findIndex(f => f.userId === userId);
            
            if (index !== -1) {
              updatedFollowers[index] = {
                ...updatedFollowers[index],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
            }
            
            return updatedFollowers;
          });
        }
        
        // Update following array if needed
        if (!isFollower) {
          setFollowing(prev => {
            const updatedFollowing = [...prev];
            const index = updatedFollowing.findIndex(f => f.userId === userId);
            
            if (index !== -1) {
              updatedFollowing[index] = {
                ...updatedFollowing[index],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
            }
            
            return updatedFollowing;
          });
        }
      } else {
        // Reset loading state on failure
        if (isFollower) {
          setFollowers(prev => {
            const updated = [...prev];
            const index = updated.findIndex(f => f.userId === userId);
            
            if (index !== -1) {
              updated[index] = {
                ...updated[index],
                isLoadingXiaohongshu: false
              };
            }
            
            return updated;
          });
        } else {
          setFollowing(prev => {
            const updated = [...prev];
            const index = updated.findIndex(f => f.userId === userId);
            
            if (index !== -1) {
              updated[index] = {
                ...updated[index],
                isLoadingXiaohongshu: false
              };
            }
            
            return updated;
          });
        }
        
        // Reset the button UI
        if (button) {
          button.classList.remove('loading');
          if (button instanceof HTMLButtonElement) {
            button.textContent = 'Follow';
            button.disabled = false;
          }
        }
      }
    } catch (error) {
      // Reset loading state on error, silently
      if (isFollower) {
        setFollowers(prev => {
          const updated = [...prev];
          const index = updated.findIndex(f => f.userId === userId);
          
          if (index !== -1) {
            updated[index] = {
              ...updated[index],
              isLoadingXiaohongshu: false
            };
          }
          
          return updated;
        });
      } else {
        setFollowing(prev => {
          const updated = [...prev];
          const index = updated.findIndex(f => f.userId === userId);
          
          if (index !== -1) {
            updated[index] = {
              ...updated[index],
              isLoadingXiaohongshu: false
            };
          }
          
          return updated;
        });
      }
      
      // Reset any loading buttons
      const button = document.querySelector(`[data-userid="${userId}"] ~ td .follow-button.loading`);
      if (button) {
        button.classList.remove('loading');
        if (button instanceof HTMLButtonElement) {
          button.textContent = 'Follow';
          button.disabled = false;
        }
      }
    }
  };

  // Function to force the UI update to Yes for a specific follower - silent operation
  const forceFollowingStatusByHandle = (handle: string) => {
    setTimeout(() => {
      // Find all matching rows for this handle and update them
      document.querySelectorAll('td').forEach(cell => {
        if (cell.textContent && cell.textContent.includes(handle)) {
          const row = cell.closest('tr');
          if (row) {
            const statusCell = row.querySelector('.following-status.no');
            if (statusCell) {
              statusCell.className = 'following-status yes';
              statusCell.textContent = 'Yes';
            }
          }
        }
      });
      
      // Also update any loading buttons
      document.querySelectorAll('.follow-button.loading').forEach(btn => {
        const parentSpan = btn.closest('.following-status');
        if (parentSpan) {
          parentSpan.className = 'following-status yes';
          parentSpan.textContent = 'Yes';
        }
      });
    }, 100);
  };

  // Create a ref to track if localStorage has been checked
  const hasCheckedLocalStorage = useRef(false);

  // Instead of using useEffect, create a function that can be called manually
  const loadFollowStatusFromStorage = useCallback(() => {
    // Don't run more than once per session
    if (hasCheckedLocalStorage.current) {
      return;
    }
    
    // Mark that we've executed this effect
    hasCheckedLocalStorage.current = true;
    
    // First check localStorage silently
    try {
      const successfulFollows = JSON.parse(localStorage.getItem('successfulFollows') || '{}');
      const userIds = Object.keys(successfulFollows);
      
      if (userIds.length > 0) {
        // Update followers once
        setFollowers(prevFollowers => {
          let hasChanges = false;
          const updatedFollowers = [...prevFollowers];
          
          userIds.forEach(userId => {
            const index = updatedFollowers.findIndex(f => f.userId === userId);
            if (index !== -1 && successfulFollows[userId].success && !updatedFollowers[index].isFollowingOnXiaohongshu) {
              updatedFollowers[index] = {
                ...updatedFollowers[index],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
              hasChanges = true;
            }
          });
          
          return hasChanges ? updatedFollowers : prevFollowers;
        });
        
        // Update following once
        setFollowing(prevFollowing => {
          let hasChanges = false;
          const updatedFollowing = [...prevFollowing];
          
          userIds.forEach(userId => {
            const index = updatedFollowing.findIndex(f => f.userId === userId);
            if (index !== -1 && successfulFollows[userId].success && !updatedFollowing[index].isFollowingOnXiaohongshu) {
              updatedFollowing[index] = {
                ...updatedFollowing[index],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
              hasChanges = true;
            }
          });
          
          return hasChanges ? updatedFollowing : prevFollowing;
        });
        
        // Force DOM updates only once
        setTimeout(() => {
          userIds.forEach(userId => {
            if (successfulFollows[userId].success) {
              document.querySelectorAll(`[data-userid="${userId}"] ~ td .following-status.no`).forEach(el => {
                el.className = 'following-status yes';
                el.textContent = 'Yes';
              });
            }
          });
        }, 500);
      }
    } catch (e) {
      // Silent fail
    }
    
    // Check chrome.storage silently
    chrome.storage.local.get(['successfulXiaohongshuFollows'], (result) => {
      const successfulFollows = result.successfulXiaohongshuFollows || {};
      const userIds = Object.keys(successfulFollows);
      
      if (userIds.length > 0) {
        // Update followers once
        setFollowers(prevFollowers => {
          let hasChanges = false;
          const updatedFollowers = [...prevFollowers];
          
          userIds.forEach(userId => {
            const index = updatedFollowers.findIndex(f => f.userId === userId);
            if (index !== -1 && successfulFollows[userId].success && !updatedFollowers[index].isFollowingOnXiaohongshu) {
              updatedFollowers[index] = {
                ...updatedFollowers[index],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
              hasChanges = true;
            }
          });
          
          return hasChanges ? updatedFollowers : prevFollowers;
        });
        
        // Update following once
        setFollowing(prevFollowing => {
          let hasChanges = false;
          const updatedFollowing = [...prevFollowing];
          
          userIds.forEach(userId => {
            const index = updatedFollowing.findIndex(f => f.userId === userId);
            if (index !== -1 && successfulFollows[userId].success && !updatedFollowing[index].isFollowingOnXiaohongshu) {
              updatedFollowing[index] = {
                ...updatedFollowing[index],
                isFollowingOnXiaohongshu: true,
                isLoadingXiaohongshu: false
              };
              hasChanges = true;
            }
          });
          
          return hasChanges ? updatedFollowing : prevFollowing;
        });
      }
    });
  }, []);
  
  // Call the function once on component mount
  useEffect(() => {
    loadFollowStatusFromStorage();
  }, [loadFollowStatusFromStorage]);
  
  // Remove the old effect that was causing issues

  return (
    <div className={`pageContent ${theme}`}>
      <div className="homeDataSources">
        <div className="titleSection">
          <div className="titleContent">
            <div className="title">Bridge your TikTok community to XiaoHongShu!</div>
            <div className="description">
              This app follows your TikTok followers and following on Xiaohongshu.
            </div>
          </div>
          <div className="switchWrapper">
            {showDebugging && (
              <div className="debug-label">Debug mode</div>
            )}
            <div 
              className={`debug-switch ${showDebugging ? 'active' : ''} ${theme}`}
              onClick={toggleDebugging}
              title={showDebugging ? "Hide debugging tools" : "Show debugging tools"}
            >
              <div className="knob-icon">
                <img src={iconSettings} alt="" style={{ width: '16px', height: '16px' }} />
              </div>
            </div>
            <PSwitch />
          </div>
        </div>
        
        <ul className="dataSourceItems">
          <li className={`dataSourceItem ${theme}`}>
            <div className="mainInfo">
              <div className="left">
                <img src={DATASOURCEMAP.tiktok.icon} alt="" className="sourceIcon" />
                <div className="breif">
                  <div className="top">
                    <div className="name">TikTok</div>
                  </div>
                  <div className="bottom">
                    <div className="balance">
                      {hasConnected ? (
                        <div>@{activeDataSouceUserInfo.userName}</div>
                      ) : (
                        'Not Connected'
                      )}
                    </div>
                  </div>
                </div>
              </div>
              <div className="right">
                <div className="tokensWrapper">
                  {hasConnected ? (
                    <button
                      onClick={handleDelete}
                      className={`deleteBtn ${theme}`}
                      title="Delete connection"
                    >
                      <i className="iconfont icon-iconDelete"></i>
                    </button>
                  ) : (
                    <button
                      onClick={handleConnect}
                      className={`PButton secondary connectBtn ${theme}`}
                      disabled={activeConnectDataSource.loading === 1 && activeConnectDataSource.dataSourceId === 'tiktok'}
                    >
                      {activeConnectDataSource.loading === 1 && activeConnectDataSource.dataSourceId === 'tiktok' ? (
                        <div className="loading-spinner"></div>
                      ) : (
                        'Connect TikTok'
                      )}
                    </button>
                  )}
                </div>
              </div>
            </div>
          </li>

          <li className={`dataSourceItem ${theme}`}>
            <div className="mainInfo">
              <div className="left">
                <img src={DATASOURCEMAP.xiaohongshu.icon} alt="" className="sourceIcon" />
                <div className="breif">
                  <div className="top">
                    <div className="name">Xiaohongshu</div>
                  </div>
                  <div className="bottom">
                    <div className="balance">
                      {hasXiaohongshuConnected ? `@${xiaohongshuUserInfo.userName}` : 'Not Connected'}
                    </div>
                  </div>
                </div>
              </div>
              <div className="right">
                <div className="tokensWrapper">
                  {hasXiaohongshuConnected ? (
                    <button
                      onClick={handleXiaohongshuDelete}
                      className={`deleteBtn ${theme}`}
                      title="Delete connection"
                    >
                      <i className="iconfont icon-iconDelete"></i>
                    </button>
                  ) : (
                    <button
                      onClick={handleXiaohongshuConnect}
                      className={`PButton secondary connectBtn ${theme}`}
                      disabled={activeConnectDataSource.loading === 1 && activeConnectDataSource.dataSourceId === 'xiaohongshu'}
                    >
                      {activeConnectDataSource.loading === 1 && activeConnectDataSource.dataSourceId === 'xiaohongshu' ? (
                        <div className="loading-spinner"></div>
                      ) : (
                        'Connect Xiaohongshu'
                      )}
                    </button>
                  )}
                </div>
              </div>
            </div>
          </li>

          <li className={`dataSourceItem ${theme}`}>
            <div className="mainInfo">
              <div className="left">
                <img src={DATASOURCEMAP.x.icon} alt="" className="sourceIcon" />
                <div className="breif">
                  <div className="top">
                    <div className="name">X (Twitter)</div>
                  </div>
                  <div className="bottom">
                    <div className="balance">Coming soon</div>
                  </div>
                </div>
              </div>
              <div className="right">
                <div className="tokensWrapper">
                </div>
              </div>
            </div>
          </li>

          <li className={`dataSourceItem ${theme}`}>
            <div className="mainInfo">
              <div className="left">
                <img src={DATASOURCEMAP.instagram.icon} alt="" className="sourceIcon" />
                <div className="breif">
                  <div className="top">
                    <div className="name">Instagram</div>
                  </div>
                  <div className="bottom">
                    <div className="balance">Coming soon</div>
                  </div>
                </div>
              </div>
              <div className="right">
                <div className="tokensWrapper">
                </div>
              </div>
            </div>
          </li>
        </ul>

        {/* New dataSourceItems list for Handle Mapping Status and Search */}
        {showDebugging && (
          <ul className="dataSourceItems debugging">
            {/* Handle Mapping Status */}
            {hasConnected && hasXiaohongshuConnected && (
              <li className={`dataSourceItem mapping-status ${theme}`}>
                <div className="mapping-status-container">
                  <div className="mapping-info">
                    <h3>Handle Mapping Status</h3>
                    
                    {autoSaveError ? (
                      <div className="mapping-error">
                        {autoSaveError}
                      </div>
                    ) : hasAutoSaved ? (
                      <div className="mapping-success">
                        <p>
                          {mappingWasFound ? 
                            `Existing mapping found in database, between TikTok handle (@${activeDataSouceUserInfo?.userName}) and 
                             Xiaohongshu handle (@${xiaohongshuUserInfo?.userName}).` :
                            `Your TikTok handle (@${activeDataSouceUserInfo?.userName}) and 
                             Xiaohongshu handle (@${xiaohongshuUserInfo?.userName}) have been 
                             successfully mapped and saved.`
                          }
                        </p>
                        <p className="timestamp">
                          {mappingWasFound ? 'Found' : 'Saved'} on {new Date().toLocaleString()}
                        </p>
                      </div>
                    ) : (
                      <div className="mapping-progress">
                        Checking and saving handle mapping...
                      </div>
                    )}
                  </div>
                </div>
              </li>
            )}

            {/* Find Xiaohongshu Handles */}
            <li className={`dataSourceItem ${theme}`}>
              <HandleSearch theme={theme} />
            </li>
          </ul>
        )}

        {/* Wrap both tables in a container */}
        <div className={`tables-container ${theme}`}>
          {hasConnected && followers?.length > 0 && (
            <div className="followers-section">
              <div className="followers-header">
                <h3>TikTok Followers ({totalFollowers})</h3>
                <button 
                  onClick={handleExportFollowers}
                  className={`PButton secondary ${theme}`}
                  title="Export followers to CSV"
                >
                  Export CSV
                </button>
              </div>
              <div className="followers-table-container">
                <table className="followers-table">
                  <thead>
                    <tr>
                      <th>Avatar</th>
                      <th>Username</th>
                      <th>Nickname</th>
                      <th>XiaoHongShu ID</th>
                      <th>Following on Xiaohongshu</th>
                    </tr>
                  </thead>
                  <tbody>
                    {/* Debug row - only show when debug mode is on */}
                    {showDebugging && (
                      <tr key="debug-follower">
                        <td>
                          <img 
                            src="https://via.placeholder.com/40" 
                            alt="Debug User" 
                            className="follower-avatar"
                            style={{ cursor: 'pointer' }}
                            title="Debug follower - demo"
                          />
                        </td>
                        <td>@debug_follower</td>
                        <td>Debug Follower</td>
                        <td>
                          <span className="xiaohongshu-handle">@955292654</span>
                        </td>
                        <td>
                          <span className="following-status no">
                            No
                            <button 
                              className="follow-button"
                              onClick={(event) => {
                                const btn = event.target as HTMLButtonElement;
                                btn.classList.add('loading');
                                btn.textContent = 'Following...';
                                btn.disabled = true;
                                
                                // For debug purposes, create variables for this specific follower
                                const debugHandle = '955292654';
                                const debugUserId = 'debug-follower-id';
                                
                                // Also mark the follower as loading in the state
                                setFollowers(prev => {
                                  const index = prev.findIndex(f => f.userId === debugUserId);
                                  if (index !== -1) {
                                    const updated = [...prev];
                                    updated[index] = {
                                      ...updated[index],
                                      isLoadingXiaohongshu: true
                                    };
                                    return updated;
                                  }
                                  return prev;
                                });
                                
                                // For debug rows, don't use handleFollowUser as they're not in the state arrays
                                // Instead use followOnXiaohongshu directly and update the DOM directly
                                followOnXiaohongshu(debugHandle, debugUserId)
                                  .then(result => {
                                    if (result.success) {
                                      // Use our new function that works by handle rather than userId 
                                      forceFollowingStatusByHandle(debugHandle);
                                    } else {
                                      // Reset the loading state silently
                                      btn.classList.remove('loading');
                                      btn.textContent = 'Follow';
                                      btn.disabled = false;
                                    }
                                  });
                              }}
                            >
                              Follow
                            </button>
                          </span>
                        </td>
                      </tr>
                    )}
                    {followers.map(follower => (
                      <>
                        <tr 
                          key={follower.userId}
                          data-userid={follower.userId}
                        >
                          <td>
                            <img 
                              src={follower.avatar || 'https://via.placeholder.com/40'} 
                              alt={follower.nickname} 
                              className="follower-avatar"
                              onClick={() => toggleUserDetails(follower.userId)}
                              style={{ cursor: 'pointer' }}
                              title={`${follower.nickname} - click for details`}
                            />
                          </td>
                          <td>@{follower.uniqueId}</td>
                          <td>{follower.nickname}</td>
                          <td>
                            {follower.isLoadingXiaohongshu ? (
                              <span className="loading-indicator">Loading...</span>
                            ) : follower.xiaohongshuHandle && follower.xiaohongshuHandle.length > 0 ? (
                              <span className="xiaohongshu-handle">@{follower.xiaohongshuHandle}</span>
                            ) : (
                              <span className="not-found">Not found</span>
                            )}
                          </td>
                          <td>
                            {follower.isLoadingXiaohongshu ? (
                              <span className="loading-indicator">Loading...</span>
                            ) : follower.isFollowingOnXiaohongshu ? (
                              <span className="following-status yes">Yes</span>
                            ) : follower.xiaohongshuHandle && follower.xiaohongshuHandle.length > 0 ? (
                              <span className="following-status no">
                                No
                                <button 
                                  className="follow-button"
                                  onClick={(event) => {
                                    const btn = event.target as HTMLButtonElement;
                                    
                                    // First check if this user is already successfully followed in storage
                                    chrome.storage.local.get(['successfulXiaohongshuFollows'], (result) => {
                                      const successfulFollows = result.successfulXiaohongshuFollows || {};
                                      
                                      if (successfulFollows[follower.userId] && successfulFollows[follower.userId].success) {
                                        // Update the UI directly
                                        const parentSpan = btn.closest('.following-status');
                                        if (parentSpan) {
                                          parentSpan.className = 'following-status yes';
                                          parentSpan.textContent = 'Yes';
                                        }
                                        
                                        // Also update the state
                                        setFollowers(prev => {
                                          const updatedFollowers = [...prev];
                                          const index = updatedFollowers.findIndex(f => f.userId === follower.userId);
                                          if (index !== -1) {
                                            updatedFollowers[index] = {
                                              ...updatedFollowers[index],
                                              isFollowingOnXiaohongshu: true
                                            };
                                          }
                                          return updatedFollowers;
                                        });
                                        
                                        return; // Don't proceed with the follow request
                                      }
                                      
                                      // If not already followed, proceed with follow attempt
                                      btn.classList.add('loading');
                                      btn.textContent = 'Following...';
                                      btn.disabled = true;
                                    
                                      // For debug purposes, create variables for this specific follower
                                      const debugHandle = follower.xiaohongshuHandle || '';
                                      const debugUserId = follower.userId;
                                      
                                      // Also mark the follower as loading in the state
                                      setFollowers(prev => {
                                        const index = prev.findIndex(f => f.userId === debugUserId);
                                        if (index !== -1) {
                                          const updated = [...prev];
                                          updated[index] = {
                                            ...updated[index],
                                            isLoadingXiaohongshu: true
                                          };
                                          return updated;
                                        }
                                        return prev;
                                      });
                                      
                                      // For debug rows, don't use handleFollowUser as they're not in the state arrays
                                      // Instead use followOnXiaohongshu directly and update the DOM directly
                                      followOnXiaohongshu(debugHandle, debugUserId)
                                        .then(result => {
                                          if (result.success) {
                                            // Use our new function that works by handle rather than userId 
                                            forceFollowingStatusByHandle(debugHandle);
                                          } else {
                                            // Reset the loading state silently
                                            btn.classList.remove('loading');
                                            btn.textContent = 'Follow';
                                            btn.disabled = false;
                                          }
                                        });
                                    });
                                  }}
                                >
                                  Follow
                                </button>
                              </span>
                            ) : (
                              <span className="not-found">No</span>
                            )}
                          </td>
                        </tr>
                        {expandedUser === follower.userId && (
                          <tr className="expanded-details">
                            <td colSpan={5}>
                              <div className="details-container">
                                <div className="details-row">
                                  <div className="details-label">User ID:</div>
                                  <div className="details-value">{follower.userId}</div>
                                </div>
                                <div className="details-row">
                                  <div className="details-label">Username:</div>
                                  <div className="details-value">@{follower.uniqueId}</div>
                                </div>
                                <div className="details-row">
                                  <div className="details-label">Nickname:</div>
                                  <div className="details-value">{follower.nickname}</div>
                                </div>
                                {follower.signature && (
                                  <div className="details-row">
                                    <div className="details-label">Bio:</div>
                                    <div className="details-value bio-text">{follower.signature}</div>
                                  </div>
                                )}
                                <div className="details-row">
                                  <div className="details-label">Followers:</div>
                                  <div className="details-value">{follower.followerCount?.toLocaleString() || 'Unknown'}</div>
                                </div>
                                <div className="details-row">
                                  <div className="details-label">Following:</div>
                                  <div className="details-value">{follower.followingCount?.toLocaleString() || 'Unknown'}</div>
                                </div>
                              </div>
                            </td>
                          </tr>
                        )}
                      </>
                    ))}
                  </tbody>
                </table>
                {hasMoreFollowers && (
                  <div className="load-more-container">
                    <button 
                      onClick={loadMoreFollowers}
                      className={`PButton secondary ${theme}`}
                    >
                      Load More
                    </button>
                  </div>
                )}
              </div>
            </div>
          )}

          {hasConnected && following?.length > 0 && (
            <div className="followers-section">
              <div className="followers-header">
                <h3>TikTok Following ({totalFollowing})</h3>
                <button 
                  onClick={handleExportFollowing}
                  className={`PButton secondary ${theme}`}
                  title="Export following to CSV"
                >
                  Export CSV
                </button>
              </div>
              <div className="followers-table-container">
                <table className="followers-table">
                  <thead>
                    <tr>
                      <th>Avatar</th>
                      <th>Username</th>
                      <th>Nickname</th>
                      <th>XiaoHongShu ID</th>
                      <th>Following on Xiaohongshu</th>
                    </tr>
                  </thead>
                  <tbody>
                    {/* Debug row - only show when debug mode is on */}
                    {showDebugging && (
                      <tr key="debug-following">
                        <td>
                          <img 
                            src="https://via.placeholder.com/40" 
                            alt="Debug User" 
                            className="follower-avatar"
                            style={{ cursor: 'pointer' }}
                            title="Debug following - demo"
                          />
                        </td>
                        <td>@debug_following</td>
                        <td>Debug Following</td>
                        <td>
                          <span className="xiaohongshu-handle">@debug_xiaohongshu2</span>
                        </td>
                        <td>
                          <span className="following-status no">
                            No
                            <button 
                              className="follow-button"
                              onClick={(event) => {
                                const btn = event.target as HTMLButtonElement;
                                btn.classList.add('loading');
                                btn.textContent = 'Following...';
                                btn.disabled = true;
                                
                                // For debug purposes, create variables for this specific following user
                                const debugHandle = 'debug_xiaohongshu';
                                const debugUserId = 'debug-following-id';
                                
                                // Also mark the following user as loading in the state
                                setFollowing(prev => {
                                  const index = prev.findIndex(f => f.userId === debugUserId);
                                  if (index !== -1) {
                                    const updated = [...prev];
                                    updated[index] = {
                                      ...updated[index],
                                      isLoadingXiaohongshu: true
                                    };
                                    return updated;
                                  }
                                  return prev;
                                });
                                
                                // For debug rows, don't use handleFollowUser as they're not in the state arrays
                                // Instead use followOnXiaohongshu directly and update the DOM directly
                                followOnXiaohongshu(debugHandle, debugUserId)
                                  .then(result => {
                                    if (result.success) {
                                      // Use our new function that works by handle rather than userId 
                                      forceFollowingStatusByHandle(debugHandle);
                                    } else {
                                      // Reset the loading state silently
                                      btn.classList.remove('loading');
                                      btn.textContent = 'Follow';
                                      btn.disabled = false;
                                    }
                                  });
                              }}
                            >
                              Follow
                            </button>
                          </span>
                        </td>
                      </tr>
                    )}
                    {following.map(user => (
                      <>
                        <tr 
                          key={user.userId}
                          data-userid={user.userId}
                        >
                          <td>
                            <img 
                              src={user.avatar || 'https://via.placeholder.com/40'} 
                              alt={user.nickname} 
                              className="follower-avatar"
                              onClick={() => toggleUserDetails(user.userId)}
                              style={{ cursor: 'pointer' }}
                              title={`${user.nickname} - click for details`}
                            />
                          </td>
                          <td>@{user.uniqueId}</td>
                          <td>{user.nickname}</td>
                          <td>
                            {user.isLoadingXiaohongshu ? (
                              <span className="loading-indicator">Loading...</span>
                            ) : user.xiaohongshuHandle && user.xiaohongshuHandle.length > 0 ? (
                              <span className="xiaohongshu-handle">@{user.xiaohongshuHandle}</span>
                            ) : (
                              <span className="not-found"></span>
                            )}
                          </td>
                          <td>
                            {user.isLoadingXiaohongshu ? (
                              <span className="loading-indicator">Loading...</span>
                            ) : user.isFollowingOnXiaohongshu ? (
                              <span className="following-status yes">Yes</span>
                            ) : user.xiaohongshuHandle && user.xiaohongshuHandle.length > 0 ? (
                              <span className="following-status no">
                                No
                                <button 
                                  className="follow-button"
                                  onClick={(event) => {
                                    const btn = event.target as HTMLButtonElement;
                                    
                                    // First check if this user is already successfully followed in storage
                                    chrome.storage.local.get(['successfulXiaohongshuFollows'], (result) => {
                                      const successfulFollows = result.successfulXiaohongshuFollows || {};
                                      
                                      if (successfulFollows[user.userId] && successfulFollows[user.userId].success) {
                                        // Update the UI directly
                                        const parentSpan = btn.closest('.following-status');
                                        if (parentSpan) {
                                          parentSpan.className = 'following-status yes';
                                          parentSpan.textContent = 'Yes';
                                        }
                                        
                                        // Also update the state
                                        setFollowing(prev => {
                                          const updatedFollowing = [...prev];
                                          const index = updatedFollowing.findIndex(f => f.userId === user.userId);
                                          if (index !== -1) {
                                            updatedFollowing[index] = {
                                              ...updatedFollowing[index],
                                              isFollowingOnXiaohongshu: true
                                            };
                                          }
                                          return updatedFollowing;
                                        });
                                        
                                        return; // Don't proceed with the follow request
                                      }
                                      
                                      // If not already followed, proceed with follow attempt
                                      btn.classList.add('loading');
                                      btn.textContent = 'Following...';
                                      btn.disabled = true;
                                    
                                      // For debug purposes, create variables for this specific following user
                                      const debugHandle = user.xiaohongshuHandle || '';
                                      const debugUserId = user.userId;
                                    
                                      // Also mark the following user as loading in the state
                                      setFollowing(prev => {
                                        const index = prev.findIndex(f => f.userId === debugUserId);
                                        if (index !== -1) {
                                          const updated = [...prev];
                                          updated[index] = {
                                            ...updated[index],
                                            isLoadingXiaohongshu: true
                                          };
                                          return updated;
                                        }
                                        return prev;
                                      });
                                      
                                      // For debug rows, don't use handleFollowUser as they're not in the state arrays
                                      // Instead use followOnXiaohongshu directly and update the DOM directly
                                      followOnXiaohongshu(debugHandle, debugUserId)
                                        .then(result => {
                                          if (result.success) {
                                            // Use our new function that works by handle rather than userId 
                                            forceFollowingStatusByHandle(debugHandle);
                                          } else {
                                            // Reset the loading state silently
                                            btn.classList.remove('loading');
                                            btn.textContent = 'Follow';
                                            btn.disabled = false;
                                          }
                                        });
                                    });
                                  }}
                                >
                                  Follow
                                </button>
                              </span>
                            ) : (
                              <span className="not-found">No</span>
                            )}
                          </td>
                        </tr>
                        {expandedUser === user.userId && (
                          <tr className="expanded-details">
                            <td colSpan={5}>
                              <div className="details-container">
                                <div className="details-row">
                                  <div className="details-label">User ID:</div>
                                  <div className="details-value">{user.userId}</div>
                                </div>
                                <div className="details-row">
                                  <div className="details-label">Username:</div>
                                  <div className="details-value">@{user.uniqueId}</div>
                                </div>
                                <div className="details-row">
                                  <div className="details-label">Nickname:</div>
                                  <div className="details-value">{user.nickname}</div>
                                </div>
                                {user.signature && (
                                  <div className="details-row">
                                    <div className="details-label">Bio:</div>
                                    <div className="details-value bio-text">{user.signature}</div>
                                  </div>
                                )}
                                <div className="details-row">
                                  <div className="details-label">Followers:</div>
                                  <div className="details-value">{user.followerCount?.toLocaleString() || 'Unknown'}</div>
                                </div>
                                <div className="details-row">
                                  <div className="details-label">Following:</div>
                                  <div className="details-value">{user.followingCount?.toLocaleString() || 'Unknown'}</div>
                                </div>
                              </div>
                            </td>
                          </tr>
                        )}
                      </>
                    ))}
                  </tbody>
                </table>
                {hasMoreFollowing && (
                  <div className="load-more-container">
                    <button 
                      onClick={loadMoreFollowing}
                      className={`PButton secondary ${theme}`}
                    >
                      Load More
                    </button>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {visibleAssetDialog && (
          <CreateZkAttestation
            presets={attestationPresets}
            type={visibleAssetDialog}
            onClose={handleCloseAssetDialog}
            onSubmit={handleSubmitAssetDialog}
          />
        )}
      </div>

    </div>
  );
};

export default IdentityBridge;